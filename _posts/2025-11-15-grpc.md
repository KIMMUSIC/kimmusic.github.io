---
title: "gRPC: ê³ ê¸‰ ê¸°ëŠ¥"
excerpt: "gRPCì˜ ì¸í„°ì…‰í„°, ë°ë“œë¼ì¸, ë©”íƒ€ë°ì´í„° ê¸°ëŠ¥ í•™ìŠµ ë° ì‹¤ìŠµ ì •ë¦¬"

categories:
    - study
header:
  teaser: "/assets/images/grpc.png"
last_modified_at: 2025-11-15
---

## ê°œìš”

"gRPC ì‹¤ìŠµë¶€í„° ìš´ì˜ê¹Œì§€" ì±…ì˜ 5ì¥ ë‚´ìš©ì„ ì‹¤ìŠµí•˜ë©´ì„œ ì¸í„°ì…‰í„°, ë°ë“œë¼ì¸, ë©”íƒ€ë°ì´í„°ì— ëŒ€í•´ ê³µë¶€í–ˆë‹¤.

### í•™ìŠµ ë‚´ìš©

**ì¸í„°ì…‰í„°(Interceptor)**ëŠ” ìš”ì²­/ì‘ë‹µ ê³¼ì •ì—ì„œ ê³µí†µ ë¡œì§ì„ ì²˜ë¦¬í•˜ëŠ” ë¯¸ë“¤ì›¨ì–´ë‹¤. ì„œë²„ ìŠ¤íŠ¸ë¦¬ë° ì¸í„°ì…‰í„°ë¥¼ êµ¬í˜„í•´ì„œ ë©”ì‹œì§€ ì†¡ìˆ˜ì‹  ê³¼ì •ì„ ë¡œê¹…í–ˆê³ , ServerStreamì„ ë˜í•‘í•´ì„œ ë©”ì‹œì§€ë¥¼ ê°€ë¡œì±„ëŠ” ë°©ë²•ì„ ìµí˜”ë‹¤.

**ë°ë“œë¼ì¸(Deadline)**ì€ ìš”ì²­ì´ ì™„ë£Œë˜ì–´ì•¼ í•˜ëŠ” ì‹œê°„ì„ ì§€ì •í•˜ëŠ” ê¸°ëŠ¥ì´ë‹¤. íƒ€ì„ì•„ì›ƒê³¼ ë‹¬ë¦¬ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ ì „íŒŒë˜ì–´ ì „ì²´ ìš”ì²­ ì‹œê°„ì„ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤. Contextë¥¼ í†µí•œ ë°ë“œë¼ì¸ ì„¤ì •ê³¼ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì²´ì¸ì—ì„œì˜ í™œìš©ë²•ì„ í•™ìŠµí–ˆë‹¤.

**ë©”íƒ€ë°ì´í„°(Metadata)**ëŠ” gRPC ìš”ì²­ê³¼ í•¨ê»˜ ì „ì†¡ë˜ëŠ” í‚¤-ê°’ í˜•íƒœì˜ í—¤ë” ì •ë³´ë‹¤. ì¸ì¦ í† í°ì´ë‚˜ ì¶”ì  ID ê°™ì€ ë¶€ê°€ ì •ë³´ë¥¼ ì „ë‹¬í•˜ëŠ” ë°©ë²•ê³¼ Header/Trailerì˜ ì°¨ì´ë¥¼ ì‹¤ìŠµí–ˆë‹¤.

---

## gRPC ì¸í„°ì…‰í„°ë€?

gRPC ì¸í„°ì…‰í„°ëŠ” ë‘ ê°€ì§€ íƒ€ì…ìœ¼ë¡œ ë‚˜ë‰œë‹¤:

1. **Unary Interceptor**: ë‹¨ì¼ ìš”ì²­-ì‘ë‹µ ë°©ì‹ì˜ RPC í˜¸ì¶œì— ì ìš©
2. **Stream Interceptor**: ìŠ¤íŠ¸ë¦¬ë° RPC í˜¸ì¶œì— ì ìš© (í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¼, ì„œë²„ ìŠ¤íŠ¸ë¦¼, ì–‘ë°©í–¥ ìŠ¤íŠ¸ë¦¼)

ì¸í„°ì…‰í„°ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤:
- ìš”ì²­/ì‘ë‹µ ë¡œê¹…
- ì¸ì¦ ë° ê¶Œí•œ ê²€ì¦
- ì—ëŸ¬ í•¸ë“¤ë§
- ë©”íŠ¸ë¦­ ìˆ˜ì§‘
- íƒ€ì„ì•„ì›ƒ ê´€ë¦¬

---

## ì„œë²„ ìŠ¤íŠ¸ë¦¬ë° ì¸í„°ì…‰í„° êµ¬í˜„

### 1. StreamServerInterceptor êµ¬ì¡°

```go
func StreamServerInterceptor(
	srv interface{},
	ss grpc.ServerStream,
	info *grpc.StreamServerInfo,
	handler grpc.StreamHandler,
) error {
	log.Printf("[Stream Interceptor] Stream started - Method: %s", info.FullMethod)

	// ì‹¤ì œ ìŠ¤íŠ¸ë¦¼ í•¸ë“¤ëŸ¬ í˜¸ì¶œ ì „ ë¡œì§
	log.Printf("[Stream Interceptor] IsClientStream: %v", info.IsClientStream)
	log.Printf("[Stream Interceptor] IsServerStream: %v", info.IsServerStream)

	// ServerStreamì„ ë˜í•‘í•˜ì—¬ Send/Recvë¥¼ ê°€ë¡œì±Œ ìˆ˜ ìˆìŒ
	wrappedStream := &wrappedServerStream{
		ServerStream: ss,
		methodName:   info.FullMethod,
	}

	// ì‹¤ì œ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
	err := handler(srv, wrappedStream)

	// í•¸ë“¤ëŸ¬ í˜¸ì¶œ í›„ ë¡œì§
	if err != nil {
		log.Printf("[Stream Interceptor] Stream ended with error: %v", err)
	} else {
		log.Printf("[Stream Interceptor] Stream ended successfully")
	}

	return err
}
```

**í•µì‹¬ í¬ì¸íŠ¸:**
- `grpc.StreamServerInfo`ë¥¼ í†µí•´ ë©”ì„œë“œ ì •ë³´, ìŠ¤íŠ¸ë¦¼ íƒ€ì… í™•ì¸
- `handler` í˜¸ì¶œ ì „í›„ë¡œ ë¡œê¹… ì²˜ë¦¬
- `ServerStream`ì„ ë˜í•‘í•˜ì—¬ ë©”ì‹œì§€ ì†¡ìˆ˜ì‹ ì„ ê°€ë¡œì±”

---

### 2. ServerStream ë˜í•‘

ë©”ì‹œì§€ ì†¡ìˆ˜ì‹ ì„ ê°€ë¡œì±„ê¸° ìœ„í•´ `grpc.ServerStream`ì„ ë˜í•‘í•˜ëŠ” êµ¬ì¡°ì²´ë¥¼ ì •ì˜í–ˆë‹¤:

```go
type wrappedServerStream struct {
	grpc.ServerStream
	methodName string
}

// SendMsg - ë©”ì‹œì§€ ì „ì†¡ ì‹œ í˜¸ì¶œë¨
func (w *wrappedServerStream) SendMsg(m interface{}) error {
	log.Printf("[Stream Interceptor] Sending message: %+v", m)
	return w.ServerStream.SendMsg(m)
}

// RecvMsg - ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ í˜¸ì¶œë¨
func (w *wrappedServerStream) RecvMsg(m interface{}) error {
	err := w.ServerStream.RecvMsg(m)
	if err == nil {
		log.Printf("[Stream Interceptor] Received message: %+v", m)
	}
	return err
}
```

`SendMsg`ì™€ `RecvMsg`ë¥¼ ì˜¤ë²„ë¼ì´ë“œí•˜ì—¬ ì‹¤ì œ ë©”ì‹œì§€ ë‚´ìš©ì„ ë¡œê¹…í•  ìˆ˜ ìˆë‹¤.

---

### 3. ì„œë²„ êµ¬í˜„

ê¸°ë³¸ì ì¸ Greeter ì„œë¹„ìŠ¤ë¥¼ êµ¬í˜„í–ˆë‹¤:

```go
type server struct {
	pb.UnimplementedGreeterServer
}

func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
	log.Printf("[Server] Received request from: %s", req.GetName())
	return &pb.HelloReply{
		Message: fmt.Sprintf("Hello, %s!", req.GetName()),
	}, nil
}

func (s *server) SayHelloStream(req *pb.HelloRequest, stream pb.Greeter_SayHelloStreamServer) error {
	name := req.GetName()
	log.Printf("[Server] Received stream request from: %s", name)

	// 3ë²ˆ ì¸ì‚¬ ë©”ì‹œì§€ ì „ì†¡
	for i := 1; i <= 3; i++ {
		if err := stream.Send(&pb.HelloReply{
			Message: fmt.Sprintf("Hello #%d, %s!", i, name),
		}); err != nil {
			return err
		}
	}

	return nil
}
```

---

### 4. ì¸í„°ì…‰í„° ë“±ë¡

gRPC ì„œë²„ ìƒì„± ì‹œ ì¸í„°ì…‰í„°ë¥¼ ë“±ë¡í•œë‹¤:

```go
func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("[Server] Failed to listen: %v", err)
	}

	// ìŠ¤íŠ¸ë¦¬ë° ì¸í„°ì…‰í„° ë“±ë¡
	s := grpc.NewServer(
		grpc.StreamInterceptor(StreamServerInterceptor),
	)

	pb.RegisterGreeterServer(s, &server{})

	log.Printf("[Server] gRPC server with STREAM interceptor running at :50051")
	log.Printf("[Server] Waiting for client requests...")

	if err := s.Serve(lis); err != nil {
		log.Fatalf("[Server] Failed to serve: %v", err)
	}
}
```

---

## ì¸í„°ì…‰í„° ì²´ì´ë‹

ì—¬ëŸ¬ ì¸í„°ì…‰í„°ë¥¼ ì²´ì¸ìœ¼ë¡œ ì—°ê²°í•  ìˆ˜ë„ ìˆë‹¤:

```go
// Unaryì™€ Stream ë‘˜ ë‹¤ ë“±ë¡
s := grpc.NewServer(
	grpc.UnaryInterceptor(UnaryInterceptor),
	grpc.StreamInterceptor(StreamServerInterceptor),
)

// ì—¬ëŸ¬ ê°œì˜ ì¸í„°ì…‰í„° ì²´ì¸
s := grpc.NewServer(
	grpc.ChainUnaryInterceptor(unaryInterceptor1, unaryInterceptor2),
	grpc.ChainStreamInterceptor(streamInterceptor1, streamInterceptor2),
)
```

---

## ì‹¤ìŠµ ê²°ê³¼

ì„œë²„ë¥¼ ì‹¤í–‰í•˜ê³  í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­ì„ ë³´ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ì€ ë¡œê·¸ê°€ ì¶œë ¥ëœë‹¤:

```
[Server] gRPC server with STREAM interceptor running at :50051
[Server] Waiting for client requests...
[Stream Interceptor] Stream started - Method: /pb.Greeter/SayHelloStream
[Stream Interceptor] IsClientStream: false
[Stream Interceptor] IsServerStream: true
[Stream Interceptor] Received message: name:"Alice"
[Server] Received stream request from: Alice
[Stream Interceptor] Sending message: message:"Hello #1, Alice!"
[Stream Interceptor] Sending message: message:"Hello #2, Alice!"
[Stream Interceptor] Sending message: message:"Hello #3, Alice!"
[Stream Interceptor] Stream ended successfully
```

---

## gRPC Deadline (ë°ë“œë¼ì¸)

### ë°ë“œë¼ì¸ì´ë€?

**Deadline**ì€ gRPC ìš”ì²­ì´ ì™„ë£Œë˜ì–´ì•¼ í•˜ëŠ” **ìµœëŒ€ ì‹œê°„**ì„ ì§€ì •í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤. íƒ€ì„ì•„ì›ƒê³¼ ë‹¬ë¦¬ ì ˆëŒ€ì  ì‹œê°„ ê°œë…ìœ¼ë¡œ, í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„¤ì •í•œ ë°ë“œë¼ì¸ì´ ì„œë²„ë¡œ ì „íŒŒë˜ì–´ ì „ì²´ ìš”ì²­ ì‹œê°„ì„ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.

**í•µì‹¬ ê°œë…:**
- **íƒ€ì„ì•„ì›ƒ vs ë°ë“œë¼ì¸**: íƒ€ì„ì•„ì›ƒì€ "ëŒ€ê¸° ì‹œê°„" (ìƒëŒ€ì ), ë°ë“œë¼ì¸ì€ "ì™„ë£Œ ê¸°í•œ" (ì ˆëŒ€ì )
- **ì „íŒŒ(Propagation)**: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„¤ì •í•œ ë°ë“œë¼ì¸ì´ ì„œë²„ë¡œ ì „ë‹¬ë¨
- **ì¡°ê¸° ì¢…ë£Œ**: ë°ë“œë¼ì¸ ì´ˆê³¼ ì‹œ ì¦‰ì‹œ ì—ëŸ¬ ë°˜í™˜, ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ ë°©ì§€

---

### ì™œ ë°ë“œë¼ì¸ì´ í•„ìš”í•œê°€?

#### 1. ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ ë°©ì§€
```
âŒ ë°ë“œë¼ì¸ ì—†ìŒ:
í´ë¼ì´ì–¸íŠ¸: 1ì´ˆ í›„ í¬ê¸°
ì„œë²„: 10ì´ˆ ë™ì•ˆ ê³„ì† ì‘ì—… ì¤‘... (ë‚­ë¹„!)

âœ… ë°ë“œë¼ì¸ ì‚¬ìš©:
í´ë¼ì´ì–¸íŠ¸: 1ì´ˆ í›„ í¬ê¸°
ì„œë²„: 1ì´ˆ í›„ ê°ì§€í•˜ê³  ì‘ì—… ì¤‘ë‹¨
```

#### 2. ì—°ì‡„ ì‹¤íŒ¨ ë°©ì§€
ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì²´ì¸ì—ì„œ ê° ì„œë¹„ìŠ¤ê°€ ì‹œê°„ ë‚´ ì‘ë‹µ ëª»í•˜ë©´ ì¦‰ì‹œ ì‹¤íŒ¨í•˜ì—¬ ì „ì²´ ì‹œìŠ¤í…œ ë¸”ë¡ì„ ë°©ì§€í•œë‹¤.

---

### Contextë¥¼ í†µí•œ ë°ë“œë¼ì¸ ì„¤ì •

#### WithTimeout (ìƒëŒ€ ì‹œê°„) - ê¶Œì¥
```go
// í˜„ì¬ ì‹œê°„ë¶€í„° 1ì´ˆ í›„
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()

resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "User"})
```

#### WithDeadline (ì ˆëŒ€ ì‹œê°„)
```go
// íŠ¹ì • ì‹œê°ê¹Œì§€
deadline := time.Now().Add(1 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "User"})
```

---

### ì„œë²„ì—ì„œ ë°ë“œë¼ì¸ í™•ì¸í•˜ê¸°

```go
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    // ë°ë“œë¼ì¸ì´ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    deadline, ok := ctx.Deadline()
    if ok {
        remaining := time.Until(deadline)
        log.Printf("ë‚¨ì€ ì‹œê°„: %v", remaining)

        if remaining < 100*time.Millisecond {
            return nil, status.Error(codes.DeadlineExceeded, "not enough time to process")
        }
    }

    // Context ì·¨ì†Œ ê°ì§€
    select {
    case <-time.After(2 * time.Second):
        // ì •ìƒ ì²˜ë¦¬ ì™„ë£Œ
        return &pb.HelloReply{Message: "Done"}, nil

    case <-ctx.Done():
        // ë°ë“œë¼ì¸ ì´ˆê³¼ ë˜ëŠ” í´ë¼ì´ì–¸íŠ¸ ì·¨ì†Œ
        err := ctx.Err()

        if err == context.DeadlineExceeded {
            log.Println("âš ï¸ Deadline exceeded!")
            return nil, status.Error(codes.DeadlineExceeded, "processing took too long")
        }

        if err == context.Canceled {
            log.Println("ğŸš« Client cancelled request")
            return nil, status.Error(codes.Canceled, "request cancelled")
        }

        return nil, err
    }
}
```

---

### ì—ëŸ¬ ì²˜ë¦¬

```go
resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "User"})
if err != nil {
    st, ok := status.FromError(err)
    if !ok {
        log.Fatal("Unknown error")
    }

    switch st.Code() {
    case codes.DeadlineExceeded:
        log.Println("â° Timeout! ì„œë²„ê°€ ì œì‹œê°„ì— ì‘ë‹µí•˜ì§€ ëª»í•¨")
        // ì¬ì‹œë„ ë¡œì§ ë˜ëŠ” fallback

    case codes.Canceled:
        log.Println("ğŸš« ìš”ì²­ì´ ì·¨ì†Œë¨")

    default:
        log.Printf("Other error: %v", st.Code())
    }
}
```

---

### íƒ€ì„ì•„ì›ƒ vs ë°ë“œë¼ì¸: í•µì‹¬ ì°¨ì´

#### íƒ€ì„ì•„ì›ƒ ë°©ì‹ (ê°ê° ë…ë¦½ì ) âŒ
```
Client (18:30:00)
  â”œâ”€ Timeout 5ì´ˆ ì„¤ì • â†’ 18:30:05ê¹Œì§€
  â”‚
  â”œâ”€â–º Service A (18:30:01 ë„ì°©)
  â”‚     â”œâ”€ Timeout 5ì´ˆ ì„¤ì • â†’ 18:30:06ê¹Œì§€ (ìƒˆë¡œ ì„¤ì •!)
  â”‚     â”‚
  â”‚     â”œâ”€â–º Service B (18:30:02 ë„ì°©)
  â”‚           â”œâ”€ Timeout 5ì´ˆ ì„¤ì • â†’ 18:30:07ê¹Œì§€ (ë˜ ìƒˆë¡œ ì„¤ì •!)
  â”‚
  â””â”€ ë¬¸ì œ: ìµœì•…ì˜ ê²½ìš° 15ì´ˆ ì´ìƒ ì†Œìš” ê°€ëŠ¥
```

#### ë°ë“œë¼ì¸ ë°©ì‹ (ëª¨ë‘ ê³µìœ ) âœ…
```
Client (18:30:00)
  â”œâ”€ Deadline ì„¤ì •: 18:30:05
  â”‚
  â”œâ”€â–º Service A (18:30:01 ë„ì°©)
  â”‚     â”œâ”€ Deadline: 18:30:05 (ë‚¨ì€ ì‹œê°„: 4ì´ˆ)
  â”‚     â”‚
  â”‚     â”œâ”€â–º Service B (18:30:02 ë„ì°©)
  â”‚           â”œâ”€ Deadline: 18:30:05 (ë‚¨ì€ ì‹œê°„: 3ì´ˆ)
  â”‚
  â””â”€ ì¥ì : ì „ì²´ ìš”ì²­ì´ ì •í™•íˆ 5ì´ˆ ì•ˆì— ì™„ë£Œ
```

**ì¤‘ìš”**: gRPCëŠ” `context.WithTimeout()`ì„ ì‚¬ìš©í•´ë„ ë‚´ë¶€ì ìœ¼ë¡œ ë°ë“œë¼ì¸ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì„œë²„ë¡œ ì „íŒŒí•œë‹¤!

---

### ìŠ¤íŠ¸ë¦¬ë°ì—ì„œì˜ ë°ë“œë¼ì¸

```go
func (s *server) SayHelloStream(req *pb.HelloRequest, stream pb.Greeter_SayHelloStreamServer) error {
    ctx := stream.Context()

    for i := 1; i <= 10; i++ {
        select {
        case <-ctx.Done():
            // ë°ë“œë¼ì¸ ì´ˆê³¼ - ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨
            log.Printf("Stream cancelled at message #%d", i)
            return status.Error(codes.DeadlineExceeded, "stream timeout")

        case <-time.After(1 * time.Second):
            if err := stream.Send(&pb.HelloReply{
                Message: fmt.Sprintf("Message #%d", i),
            }); err != nil {
                return err
            }
        }
    }

    return nil
}
```

---

### ëª¨ë²” ì‚¬ë¡€

#### 1. í•­ìƒ ë°ë“œë¼ì¸ ì„¤ì •
```go
// âŒ ë‚˜ìœ ì˜ˆ: ë°ë“œë¼ì¸ ì—†ìŒ
resp, err := client.SayHello(context.Background(), req)

// âœ… ì¢‹ì€ ì˜ˆ: ì ì ˆí•œ ë°ë“œë¼ì¸
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
resp, err := client.SayHello(ctx, req)
```

#### 2. defer cancel() í•­ìƒ í˜¸ì¶œ
```go
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel() // âœ… ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€
```

#### 3. ì„œë²„ì—ì„œ Context ì „íŒŒ

##### âŒ ì˜ëª»ëœ ë°©ë²•
```go
// Client
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
resp, err := client.CallServiceA(ctx, req)

// Service A (ì„œë²„)
func (s *ServiceA) Handle(ctx context.Context, req *pb.Request) (*pb.Response, error) {
    // âŒ ì˜ëª»: ë°›ì€ context ë¬´ì‹œí•˜ê³  ìƒˆë¡œ ë§Œë“¦!
    newCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Service B í˜¸ì¶œ
    return s.serviceBClient.Call(newCtx, req)
}
```

##### âœ… ì˜¬ë°”ë¥¸ ë°©ë²•
```go
// Client
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
resp, err := client.CallServiceA(ctx, req)

// Service A (ì„œë²„)
func (s *ServiceA) Handle(ctx context.Context, req *pb.Request) (*pb.Response, error) {
    // âœ… ì˜¬ë°”ë¦„: ë°›ì€ context ê·¸ëŒ€ë¡œ ì‚¬ìš©!
    deadline, _ := ctx.Deadline()
    log.Printf("Deadline: %v, ë‚¨ì€ ì‹œê°„: %v", deadline, time.Until(deadline))

    // Service B í˜¸ì¶œ (ê°™ì€ ctx ì „ë‹¬!)
    resp, err := s.serviceBClient.Call(ctx, req)
    if err != nil {
        return nil, err
    }
    return &pb.Response{Data: resp.Data}, nil
}
```

#### 4. ì¬ì‹œë„ with ë°ë“œë¼ì¸
```go
func CallWithRetry(client pb.GreeterClient, name string) (*pb.HelloReply, error) {
    maxRetries := 3
    timeout := 1 * time.Second

    for i := 0; i < maxRetries; i++ {
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        
        resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: name})
        cancel() // ì¦‰ì‹œ í˜¸ì¶œ
        
        if err == nil {
            return resp, nil
        }

        st := status.Convert(err)
        if st.Code() != codes.DeadlineExceeded {
            return nil, err
        }

        log.Printf("Retry %d/%d after timeout", i+1, maxRetries)
        time.Sleep(100 * time.Millisecond)
    }

    return nil, status.Error(codes.DeadlineExceeded, "all retries failed")
}
```

---

## gRPC ë©”íƒ€ë°ì´í„° (Metadata)

### ë©”íƒ€ë°ì´í„°ë€?

**ë©”íƒ€ë°ì´í„°(Metadata)**ëŠ” gRPC ìš”ì²­/ì‘ë‹µê³¼ í•¨ê»˜ ì „ì†¡ë˜ëŠ” **í‚¤-ê°’ ìŒì˜ í—¤ë” ì •ë³´**ë‹¤. gRPCëŠ” HTTP/2 ìœ„ì—ì„œ ë™ì‘í•˜ë¯€ë¡œ, ë©”íƒ€ë°ì´í„°ëŠ” **HTTP/2 í—¤ë”**ë¡œ ì „ì†¡ëœë‹¤.

```
HTTP/2 í—¤ë”:
  :method: POST
  :path: /greeter.Greeter/SayHello
  content-type: application/grpc
  authorization: Bearer token123    â† ë©”íƒ€ë°ì´í„°
  user-id: john.doe                 â† ë©”íƒ€ë°ì´í„°
  trace-id: ABC-123                 â† ë©”íƒ€ë°ì´í„°
```

---

### ë©”íƒ€ë°ì´í„° ì‚¬ìš© ì‚¬ë¡€

ë©”íƒ€ë°ì´í„°ëŠ” ë‹¤ì–‘í•œ ëª©ì ìœ¼ë¡œ í™œìš©ëœë‹¤:

1. **ì¸ì¦(Authentication)**: `authorization: Bearer token`
2. **ë¶„ì‚° ì¶”ì (Distributed Tracing)**: `trace-id`, `span-id`
3. **ì‚¬ìš©ì ì •ë³´**: `user-id`, `user-role`, `user-tenant`
4. **ìš”ì²­ ë©”íƒ€ ì •ë³´**: `request-id`, `client-version`, `device-type`
5. **ê¸°ëŠ¥ í”Œë˜ê·¸**: `feature-flags`, `ab-test-group`

---

### ë©”íƒ€ë°ì´í„° íƒ€ì…

#### 1. Header (í—¤ë”)
- **ì „ì†¡ ì‹œì **: RPC ì‹œì‘ ì‹œ
- **ìš©ë„**: ìš”ì²­ ì •ë³´, ì¸ì¦, ì¶”ì  ë“±
- **íŠ¹ì§•**: RPC ì‹œì‘ ì „ì— ì „ì†¡ë¨

#### 2. Trailer (íŠ¸ë ˆì¼ëŸ¬)
- **ì „ì†¡ ì‹œì **: RPC ì¢…ë£Œ ì‹œ
- **ìš©ë„**: ì²˜ë¦¬ ê²°ê³¼, í†µê³„, ìƒíƒœ ì •ë³´
- **íŠ¹ì§•**: ì‘ë‹µ ë³¸ë¬¸ ì´í›„ ì „ì†¡ë¨

---

### í´ë¼ì´ì–¸íŠ¸: ë©”íƒ€ë°ì´í„° ì „ì†¡

#### ë°©ë²• 1: metadata.Pairs ì‚¬ìš© (ê¶Œì¥)

```go
// ë©”íƒ€ë°ì´í„° ìƒì„±
md := metadata.Pairs(
    "user-id", "john",
    "trace-id", "ABC-123",
    "authorization", "Bearer token",
)

// Contextì— ì¶”ê°€
ctx := metadata.NewOutgoingContext(context.Background(), md)

// RPC í˜¸ì¶œ
resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "User"})
```

#### ë°©ë²• 2: ê¸°ì¡´ Contextì— ì¶”ê°€

```go
// ê¸°ì¡´ Contextê°€ ìˆëŠ” ê²½ìš°
ctx := context.Background()

// ë©”íƒ€ë°ì´í„° ì¶”ê°€
ctx = metadata.AppendToOutgoingContext(ctx,
    "user-id", "john",
    "trace-id", "ABC-123",
)

resp, err := client.SayHello(ctx, req)
```

---

### ì„œë²„: ë©”íƒ€ë°ì´í„° ìˆ˜ì‹ 

```go
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    // ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.InvalidArgument, "no metadata")
    }

    // ëª¨ë“  ë©”íƒ€ë°ì´í„° ì¶œë ¥
    for key, values := range md {
        for _, value := range values {
            log.Printf("%s: %s", key, value)
        }
    }

    // íŠ¹ì • í‚¤ ê°’ ê°€ì ¸ì˜¤ê¸°
    if tokens := md.Get("authorization"); len(tokens) > 0 {
        token := tokens[0]
        log.Printf("Token: %s", token)
        // í† í° ê²€ì¦...
    }

    // ì‚¬ìš©ì ID ê°€ì ¸ì˜¤ê¸°
    if userIDs := md.Get("user-id"); len(userIDs) > 0 {
        userID := userIDs[0]
        log.Printf("User ID: %s", userID)
    }

    return &pb.HelloReply{Message: "OK"}, nil
}
```

---

### ì„œë²„: ë©”íƒ€ë°ì´í„° ì „ì†¡

#### Header ë©”íƒ€ë°ì´í„° ì „ì†¡

```go
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    // í—¤ë” ë©”íƒ€ë°ì´í„° ìƒì„±
    header := metadata.Pairs(
        "server-version", "1.0.0",
        "request-id", "REQ-123",
    )

    // í—¤ë” ì „ì†¡ (ì‘ë‹µ ì‹œì‘ ì‹œ)
    if err := grpc.SendHeader(ctx, header); err != nil {
        return nil, err
    }

    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§...

    return &pb.HelloReply{Message: "OK"}, nil
}
```

#### Trailer ë©”íƒ€ë°ì´í„° ì „ì†¡

```go
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§...

    // íŠ¸ë ˆì¼ëŸ¬ ë©”íƒ€ë°ì´í„° ì„¤ì • (ì‘ë‹µ ì¢…ë£Œ ì‹œ)
    trailer := metadata.Pairs(
        "server-status", "ok",
        "processing-time-ms", "42",
    )
    grpc.SetTrailer(ctx, trailer)

    return &pb.HelloReply{Message: "OK"}, nil
}
```

---

### í´ë¼ì´ì–¸íŠ¸: ë©”íƒ€ë°ì´í„° ìˆ˜ì‹ 

```go
var header, trailer metadata.MD

resp, err := client.SayHello(ctx, req,
    grpc.Header(&header),   // í—¤ë” ìˆ˜ì‹ 
    grpc.Trailer(&trailer), // íŠ¸ë ˆì¼ëŸ¬ ìˆ˜ì‹ 
)

if err != nil {
    log.Fatal(err)
}

// í—¤ë” ì½ê¸°
if versions := header.Get("server-version"); len(versions) > 0 {
    log.Printf("Server version: %s", versions[0])
}

// íŠ¸ë ˆì¼ëŸ¬ ì½ê¸°
if statuses := trailer.Get("server-status"); len(statuses) > 0 {
    log.Printf("Status: %s", statuses[0])
}
```

---

### ìŠ¤íŠ¸ë¦¬ë°ì—ì„œì˜ ë©”íƒ€ë°ì´í„°

```go
// ì„œë²„
func (s *server) SayHelloStream(req *pb.HelloRequest, stream pb.Greeter_SayHelloStreamServer) error {
    // ìˆ˜ì‹  ë©”íƒ€ë°ì´í„° ì½ê¸°
    ctx := stream.Context()
    md, _ := metadata.FromIncomingContext(ctx)

    // í—¤ë” ì „ì†¡
    header := metadata.Pairs("stream-id", "STREAM-123")
    if err := stream.SendHeader(header); err != nil {
        return err
    }

    // ë©”ì‹œì§€ ì „ì†¡...
    for i := 0; i < 5; i++ {
        stream.Send(&pb.HelloReply{Message: fmt.Sprintf("Message %d", i)})
    }

    // íŠ¸ë ˆì¼ëŸ¬ ì„¤ì •
    stream.SetTrailer(metadata.Pairs("total-messages", "5"))

    return nil
}

// í´ë¼ì´ì–¸íŠ¸
func callStream(client pb.GreeterClient) {
    // ë©”íƒ€ë°ì´í„° ì „ì†¡
    md := metadata.Pairs("priority", "high")
    ctx := metadata.NewOutgoingContext(context.Background(), md)

    stream, err := client.SayHelloStream(ctx, &pb.HelloRequest{Name: "User"})

    // í—¤ë” ìˆ˜ì‹ 
    header, err := stream.Header()
    log.Println(header)

    // ë©”ì‹œì§€ ìˆ˜ì‹ 
    for {
        resp, err := stream.Recv()
        if err == io.EOF {
            break
        }
        log.Println(resp.Message)
    }

    // íŠ¸ë ˆì¼ëŸ¬ ìˆ˜ì‹ 
    trailer := stream.Trailer()
    log.Println(trailer)
}
```

---

### ë©”íƒ€ë°ì´í„° í‚¤ ê·œì¹™

#### 1. ì†Œë¬¸ì ì‚¬ìš©
```go
// âœ… ì˜¬ë°”ë¦„
md := metadata.Pairs("user-id", "john")

// âŒ ì˜ëª»ë¨ (ìë™ìœ¼ë¡œ ì†Œë¬¸ì ë³€í™˜ë¨)
md := metadata.Pairs("User-ID", "john")
```

#### 2. ASCII ë¬¸ìë§Œ ì‚¬ìš©
```go
// âœ… ì˜¬ë°”ë¦„
md := metadata.Pairs("user-id", "john")

// âŒ ì˜ëª»ë¨
md := metadata.Pairs("ì‚¬ìš©ì-id", "john")
```

#### 3. ì˜ˆì•½ì–´ í”¼í•˜ê¸°
```go
// âŒ gRPC ì˜ˆì•½ì–´: "grpc-"ë¡œ ì‹œì‘í•˜ëŠ” í‚¤ëŠ” í”¼í•  ê²ƒ
// âŒ HTTP/2 ì˜ˆì•½ì–´: ":method", ":path", ":authority" ë“±
```

#### 4. ë°”ì´ë„ˆë¦¬ ë°ì´í„°ëŠ” "-bin" ì ‘ë¯¸ì‚¬
```go
// ë°”ì´ë„ˆë¦¬ ê°’ì€ ìë™ìœ¼ë¡œ base64 ì¸ì½”ë”©ë¨
md := metadata.Pairs("image-bin", string(imageBytes))
```

---

### ì‹¤ì „ íŒ¨í„´

#### 1. ì¸ì¦ ì¸í„°ì…‰í„°

```go
func AuthInterceptor(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (interface{}, error) {
    // ë©”íƒ€ë°ì´í„°ì—ì„œ í† í° ì¶”ì¶œ
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Unauthenticated, "no metadata")
    }

    tokens := md.Get("authorization")
    if len(tokens) == 0 {
        return nil, status.Error(codes.Unauthenticated, "no token")
    }

    token := tokens[0]

    // í† í° ê²€ì¦
    if !validateToken(token) {
        return nil, status.Error(codes.Unauthenticated, "invalid token")
    }

    // ê²€ì¦ ì„±ê³µ - ì‚¬ìš©ì ì •ë³´ë¥¼ Contextì— ì¶”ê°€
    ctx = context.WithValue(ctx, "user-id", extractUserID(token))

    return handler(ctx, req)
}
```

#### 2. ì¶”ì  ID ì „íŒŒ

```go
// í´ë¼ì´ì–¸íŠ¸
func callWithTracing(client pb.GreeterClient) {
    traceID := generateTraceID()

    ctx := metadata.AppendToOutgoingContext(context.Background(),
        "trace-id", traceID,
    )

    resp, err := client.SayHello(ctx, req)
}

// ì„œë²„
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.InvalidArgument, "no metadata")
    }
    
    traceIDs := md.Get("trace-id")
    if len(traceIDs) == 0 {
        return nil, status.Error(codes.InvalidArgument, "no trace-id")
    }
    traceID := traceIDs[0]

    log.Printf("[%s] Processing request", traceID)

    // ë‹¤ë¥¸ ì„œë¹„ìŠ¤ í˜¸ì¶œ ì‹œ trace-id ì „íŒŒ
    ctx = metadata.AppendToOutgoingContext(ctx, "trace-id", traceID)
    resp, err := s.otherClient.Call(ctx, otherReq)

    return resp, err
}
```

---

### ì£¼ì˜ì‚¬í•­

#### 1. ë©”íƒ€ë°ì´í„° í¬ê¸° ì œí•œ
- HTTP/2 í—¤ë” í¬ê¸° ì œí•œ (ì¼ë°˜ì ìœ¼ë¡œ 8KB)
- í° ë°ì´í„°ëŠ” ìš”ì²­ ë³¸ë¬¸ì— í¬í•¨

#### 2. ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì•ˆ ë¨
```go
md := metadata.Pairs("User-ID", "john")
// ìë™ìœ¼ë¡œ "user-id"ë¡œ ë³€í™˜ë¨
```

#### 3. ì—¬ëŸ¬ ê°’ ì§€ì›
```go
// ê°™ì€ í‚¤ì— ì—¬ëŸ¬ ê°’ ì¶”ê°€ ê°€ëŠ¥
md := metadata.Pairs(
    "tag", "important",
    "tag", "urgent",
    "tag", "high-priority",
)

// ì„œë²„ì—ì„œ ì½ê¸°
tags := md.Get("tag")  // []string{"important", "urgent", "high-priority"}
```

#### 4. ë¯¼ê° ì •ë³´ ì£¼ì˜
```go
// âŒ ì ˆëŒ€ í•˜ì§€ ë§ ê²ƒ
md := metadata.Pairs("password", "secret123")

// âœ… í† í° ì‚¬ìš©
md := metadata.Pairs("authorization", "Bearer " + token)
```

---

## ì •ë¦¬

ì´ë²ˆ ì‹¤ìŠµì„ í†µí•´ gRPCì˜ ì„¸ ê°€ì§€ ê³ ê¸‰ ê¸°ëŠ¥ì„ ìµí˜”ë‹¤.

**ì¸í„°ì…‰í„°**ëŠ” ë¡œê¹…ì´ë‚˜ ì¸ì¦ ê°™ì€ ê³µí†µ ë¡œì§ì„ ì²˜ë¦¬í•˜ëŠ” ë° ìœ ìš©í–ˆë‹¤. íŠ¹íˆ ServerStreamì„ ë˜í•‘í•´ì„œ ë©”ì‹œì§€ë¥¼ ê°€ë¡œì±„ëŠ” ë°©ì‹ì´ ì¸ìƒì ì´ì—ˆë‹¤.

**ë°ë“œë¼ì¸**ì€ íƒ€ì„ì•„ì›ƒê³¼ ë¹„ìŠ·í•´ ë³´ì´ì§€ë§Œ ì„œë²„ë¡œ ì „íŒŒëœë‹¤ëŠ” ì ì´ ì¤‘ìš”í–ˆë‹¤. ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì²´ì¸ì—ì„œ ì „ì²´ ìš”ì²­ ì‹œê°„ì„ ê´€ë¦¬í•  ìˆ˜ ìˆì–´ì„œ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ë¥¼ ë§‰ì„ ìˆ˜ ìˆë‹¤.

**ë©”íƒ€ë°ì´í„°**ëŠ” HTTP/2 í—¤ë”ë¡œ ì „ì†¡ë˜ëŠ” ë¶€ê°€ ì •ë³´ë‹¤. ì¸ì¦ í† í°ì´ë‚˜ ì¶”ì  IDë¥¼ ì „ë‹¬í•  ë•Œ ì‚¬ìš©í•˜ë©´ ë˜ê³ , Headerì™€ Trailerë¥¼ êµ¬ë¶„í•´ì„œ ì“¸ ìˆ˜ ìˆë‹¤ëŠ” ê±¸ ë°°ì› ë‹¤.

ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•  ë•ŒëŠ” ì¸í„°ì…‰í„°ì— ì¸ì¦ê³¼ ë¡œê¹…ì„ ë„£ê³ , ëª¨ë“  ìš”ì²­ì— ë°ë“œë¼ì¸ì„ ì„¤ì •í•˜ê³ , ë©”íƒ€ë°ì´í„°ë¡œ ì¶”ì  ì •ë³´ë¥¼ ì „ë‹¬í•˜ëŠ” ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ë  ê²ƒ ê°™ë‹¤.
